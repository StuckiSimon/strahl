%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% coding: utf-8
%%% End:
% !TEX TS-program = pdflatexmk
% !TEX encoding = UTF-8 Unicode
% !TEX root = ../main.tex

The main goal is to implement a web-based ray tracer addressing the problem of the large number of variants for CAD-based product visualization leveraging data close to the production CAD models.

\section{Scene Description}
Lights, Materials, Camera, Objects
\section{Implementation}
\subsection{Ray Tracing}
\subsubsection{Uber Shader}

The OpenPBR standard is based on an über shader approach. This differs from node-based approaches such as MaterialX in that it uses a fixed set of inputs which can be configured. This approach offers a good balance between flexibility and performance.

\subsubsection{RGB, Spectral}
\subsubsection{Memory}

Memory Alignment (GPU), Memory Management (GPU+CPU)

\subsection{Random Number Generator}

To simulate light transport, the path tracer needs to pick random directions. Generating a random direction vector, defined as $v = (x, y, z)$, can be achieved by picking three random numbers independent of one another. This is done using a random number generator (RNG). Unlike other programming languages, WGSL does not have a built-in RNG. Therefore, a custom RNG is required. There are a variety of RNGs available which differ in important characteristics. Domains such as cryptography require unpredictability of the RNG to prevent an adversary from predicting secret keys. However, for a path tracer, it is more important to have high performance.
As per \cite{o2014pcg}, some of the characteristics to consider when choosing a suitable RNG are:

\begin{itemize}
    \item{Statistical Quality} – The RNG should generate numbers that are statistically random. This means that the numbers should be uniformly distributed and have a low correlation between them.
    \item{Period} – The length of the cycle before the sequence of generated numbers starts to repeat itself.
    \item{Time Performance} – The time it takes to generate a random number. This is influenced by the algorithm as well as the hardware which may support dedicated instructions.
\end{itemize}

Therefore, a pseudorandom number generator is used. Pseudorandomness satisfies the requirement of randomness but is following a deterministic algorithm.

RNG can be implemented by Xorshifts such as described by Marsaglia \cite{marsaglia2003xorshift}. The algorithm can be defined as shown in Figure \ref{code:xorShift}. $x$ is the state of the RNG and $a$, $b$ and $c$ are constants. Frequent choices for these constants are $a = 13$, $b = 17$ and $c = 5$.

\begin{figure}[H]
\begin{lstlisting}[style=wgsl]
x ^= x << a;
x ^= x >> b;
x ^= x << c;
\end{lstlisting}
\caption{Xorshift RNG implementation in WGSL.}
\label{code:xorShift}
\end{figure}

A number of suitable RNGs are available, including Mersenne Twister \cite{rngMersenneTwister}, Xorshifts such as the method described by Marsaglia \cite{marsaglia2003xorshift} and more.

However, the renderer uses PCG as the RNG due to its good performance and quality \cite{o2014pcg}.

\subsection{WebGPU}
\subsection{Integration}
\section{Use Case Scenarios}
\section{Performance}