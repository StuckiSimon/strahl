%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% coding: utf-8
%%% End:
% !TEX TS-program = pdflatexmk
% !TEX encoding = UTF-8 Unicode
% !TEX root = ../main.tex

This section provides an overview of applications of a real-time ray tracer and prior work conducted in this field, highlighting the base procedure and the novel aspects of this work. The goal is to demonstrate the potential and applicability of the developed solution. Details on the involved concepts and technologies will be discussed in \autoref{ch:theory}, but may already be referenced during the introduction.

Rasterization is a rendering technique that projects 3D scene geometry onto a 2D plane. Historically, the technique has been widely adopted in real-time rendering due to its efficiency. However, rasterization has limitations in achieving photorealism. One of the main limitations is the lack of support for global illumination. These phenomena can be observed in objects like mirrors or metallic surfaces. Effects such as refraction, reflection, and ambient occlusion require additional techniques.

Various methods have been developed to address these limitations, but these approaches induce complexity, may need to be computed at the assembly level, and can be computationally expensive. An alternative rendering technique resembles reality more closely and inherently alleviates these limitations: ray tracing.

Ray tracing is a powerful technique for rendering photorealistic scenes including global illumination. Historically, ray tracing has been mainly used in offline rendering due to its computational complexity. However, advancements in hardware have enabled real-time ray tracing in a variety of domains. In addition, the development of a new web \fGls{API}{\e{Application Programming Interface}} for leveraging the power of \fGlspl{GPU}{\e{Graphics Processing Unit}, specialized processor for parallel computation}, WebGPU, has opened up new possibilities for real-time ray tracing in the browser.

\section{Use Cases}

The web is a versatile platform which can be used for a variety of applications. This section outlines some real-world use cases for web-based 3D rendering.

One such use case is e-commerce. Historically, companies with a vast portfolio of products have provided physical catalogues to their customers. This approach hit limits mainly for use cases where configurations of multiple components are possible and the number of combinations is vast or not enumerable. This is where real-time rendering can be used to provide a more interactive experience by showing the customer a realistic representation of the product instead of a list of static images.

As long as the configurations are enumerable it is theoretically possible to pre-render the combinations using offline renderers. However, this induces cost in terms of required processing power and storage.

When opting to use real-time rendering, one option to choose is remote rendering which employs a server to render the scene and stream the visualization to the browser. The main drawbacks of this approach include network latency and full reliance on network stability. Additionally, the cost of running the server falls on the service provider.

Another option is to use client-side rendering. Generally, rasterization approaches are used for real-time rendering. However, as will be discussed in the following sections, rasterization has limitations in terms of realism when having limited control over the models.

When all these requirements are considered, the need for a real-time ray tracing solution in the web becomes apparent.

\subsection{CAD Models}

E-commerce represents a key use case for product renderings. Traditional catalogues struggle with highly configurable products. Computer graphics addresses this challenge through product configurators for virtual assembly and visualization.

Leveraging existing CAD models, prevalent in mechanical engineering and product design, for end-user applications offers a significant advantage. These models contain geometric and material information, which eliminates the need for redundant 3D models for marketing purposes. One example is EAO, which manufactures highly customizable industrial pushbuttons and operator panels. Due to the nature of the product, the number of possible assemblies grows almost exponentially with the number of components. To facilitate the configuration process, a web-based configurator is optimal because it can be used on a large variety of devices without having to install additional software. Given the company's priority for photorealistic renderings of the assemblies, using ray tracing techniques is a compelling choice.

Pre-rendering all product configurations is theoretically possible for a finite number of configurations, but computationally expensive. If this is not feasible, real-time rendering is an alternative. For real-time rendering, one option is remote rendering \cite{remoteRendering}, which employs a server to render the scene and stream the visualization to the browser. The main drawbacks of this approach are network latency, reliance on network stability, as well as operational cost for the server infrastructure, which frequently requires dedicated GPUs for rendering. Another option is client-side rendering. Most frequently, rasterization approaches are used for web-based renderings. However, due to the limitations in global illumination effects, the need for a real-time, client-side ray tracing solution for the web becomes apparent when considering the use case.

\subsection{Industry Use Cases}

One example of such a use case can be found at the company EAO. They produce industrial pushbuttons, keypads and other operator panels. The products are highly customizable and can be configured in a variety of ways. In order to facilitate the configuration process, a web-based configurator is optimal because it can be used on a large variety of devices without having to install additional software.

In addition to these factors, the pre-processing step should also define information on what kind of components can be added to the assembly and where they can be attached to. This can be done by providing meta information files containing the information. Alternatively, this can also be represented geometrically within the model by using identifiable shapes to attach components to.

\section{Prior Work}

Work has been conducted in related fields, this includes research into applicability of WebGPU as well as writing web based path tracers using WebGL. However, to the best of my knowledge, no open-source path tracing library using WebGPU has been developed.

\subsection{WebGPU}

Different other applications of WebGPU have been investigated in the past years. One such example is Dynamical.JS, a framework to visualize graphs \cite{dotson2022dynamicaljs}. Another example is RenderCore, a research-oriented rendering engine \cite{Bohak_Kovalskyi_Linev_Mrak_Tadel_Strban_Tadel_Yagil_2024}, or demonstrations on how to use WebGPU for client-side data aggregation \cite{kimmersdorfer2023webgpu}.

Investigation into the performance of WebGPU have been conducted and show that WebGPU can be faster than WebGL \cite{webGPUWebGis, fransson2023performance, CHICKERUR2024919}.
 

\subsection{Web Path Tracers}

There are a variety of path tracers available for the web. Most of them are based on WebGL, a web standard which will be highlighted in the following sections.

The first experiments of using WebGL for path tracing were implemented as early as 2010. One such example is the demo by Evan Wallace showcasing a Cornell Box with basic primitive shapes such as spheres and planes \cite{pathTracerWallace}.

Since then, a variety of open-source implementations for the web have been created.

\subsection{Three.js-based Ray Tracers}

Some of the most widely known path tracers are based on Three.js. Including:

\begin{itemize}
    \item {\texttt{three-gpu-pathtracer}} \cite{ThreeJsPathTracerJohnson}.
    \item{\texttt{Three.js PathTracer}} \cite{ThreeJsPathTracerLoftis}.
    \item {\texttt{dspbr-pt}} \cite{PathTracerDassault}.
  \end{itemize}
